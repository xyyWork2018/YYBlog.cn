{"meta":{"title":"一个记录错题&&学习的过程","subtitle":"如果不逼自己一次，就永远不知道自己是多么的有潜力","description":"记录自己学习编程语言和记录自己刷体重出现的问题的过程","author":"YY","url":"https://xyywork2018.github.io"},"pages":[{"title":"关于YY","date":"2018-08-17T08:11:16.000Z","updated":"2018-08-23T08:10:09.927Z","comments":true,"path":"about/index.html","permalink":"https://xyywork2018.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"数组去重","slug":"array-deduplication","date":"2018-09-22T16:00:00.000Z","updated":"2018-09-23T06:04:29.435Z","comments":true,"path":"2018/09/23/array-deduplication/","link":"","permalink":"https://xyywork2018.github.io/2018/09/23/array-deduplication/","excerpt":"","text":"","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xyywork2018.github.io/tags/JavaScript/"}],"keywords":[]},{"title":"字符串之间的转换","slug":"string-conversion","date":"2018-09-19T16:00:00.000Z","updated":"2018-09-23T05:54:08.847Z","comments":true,"path":"2018/09/20/string-conversion/","link":"","permalink":"https://xyywork2018.github.io/2018/09/20/string-conversion/","excerpt":"","text":"字符串可以转成2进制、8进制、10进制、16进制，还有数组。转成进制这种，一般在项目中用到的少，可能面试的时候会碰到一些，但是字符串转和数组之间的转换，用到的还是挺频繁的。 JS字符串与二进制之间的转换字符串转成ASCII码，使用charCodeAt()12'A'.charCodeAt(); // 65'a'.charCodeAt(); // 97 ASCII码转字符串，使用fromCharCode()12String.fromCharCode(65); // 'A'String.fromCharCode(97); // 'a' 十进制转二进制123'i'.charCodeAt().toString(2); // 1101001 '我'.charCodeAt().toString(2); // 110001000010001'我们'.charCadeAt().toString(2); // 110001000010001 100111011101100 二进制转成Unicode字符串12345678910111213function binaryToStr(str) &#123; var result = []; var list = str.split(' '); for (var i = 0;i &lt; list.length;i++) &#123; var item = list[i]; var asciiCode = parseInt(item, 2); var charValue = String.fromCharCode(asciiCode); result.push(charValue); &#125; return result.join('');&#125;console.log(binaryToStr(\"110001000010001 100111011101100\")); // 我们console.log(binaryToStr(\"1000000 100101 100100 101011\")); // @%$+ 字符串转换成二进制，中间用空格隔开123456789101112131415function strToBinary(str) &#123; var result = []; var list = str.split(''); for (var i = 0; i &lt; list.length; i++) &#123; if (i !== 0) &#123; result.push(' '); &#125; var item = list[i]; var binaryStr = item.charCodeAt().toString(2); result.push(binaryStr); &#125; return result.join('');&#125;console.log(strToBinary(\"我们\")); //110001000010001 100111011101100console.log(strToBinary(\"@%$+\")); //1000000 100101 100100 101011 其他转十进制123parseInt(110, 2); // 二进制 6parseInt(110, 8); // 八进制 72parseInt(110, 16); // 十六进制 272 其他转其他先使用parseInt转成十进制，再用toString转到目标进制12String.fromCharCode(parseInt(141, 8)); // aparseInt('ff', 16).toString(2); // 11111111 十进制转其他12345var str = 66;str.toString(2); // 1000010str.toString(8); // 102str.toString(16); // 42str.toString(32); // 22 参考网站：JS字符串与二进制的相互转化javascript 进制转换(2进制、8进制、10进制、16进制之间的转换)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xyywork2018.github.io/tags/JavaScript/"}],"keywords":[]},{"title":"数组过滤的方法","slug":"study-2","date":"2018-09-18T16:00:00.000Z","updated":"2018-09-19T09:27:22.524Z","comments":true,"path":"2018/09/19/study-2/","link":"","permalink":"https://xyywork2018.github.io/2018/09/19/study-2/","excerpt":"","text":"就在昨天，我对象给我推荐了一个刷题网站，叫codewars，打开之后都是英文，就有点儿抵触，哈哈，但是在我蓝朋友的强烈要求下，我今天就来用用这个网站。登录注册成功后，你可以选择你会的语言进行刷题，看到语言选择的时候，我觉得我会的实在是太少，还是要多多学习才行，做完题后进行运行，如果通过之后可以点击SUBMIT FINAL按钮，查看其它大神对这道题的写法，可以学习不一样的思路。虽然都是英文，但是慢慢看还是可以看懂的。 今天在网站上做了两道题，一道是通过判断字符串的长度，显示中间字符的，另一道是过滤数组，显示Number类型的字符，但是第一道题我还没有写完，不小心点了其他的地方，结果我就再也没有找到这道题T_T，如果以后刷题的时候再碰到，在重新总结 说说第二道第，是从一个数组中，过滤掉string类型的字符，只显示number类型的字符123456function filter_list(l) &#123; return l.filter(item =&gt; &#123; if (typeof item === 'string') return false; &#125;); return true;&#125;; 使用ES6的filter进行过滤，实现题目中的需求，获取只有number类型的数组。后来又看了很多大神的其他写法，学习总结一下，可以用更简洁的代码实现123function filter_list(l) &#123; return l.filter(item =&gt; typeof item === 'number');&#125; 使用这种方法，代码就会很简洁，以后要坚持刷题，至少每天一道，积少成多，巩固一些算法知识，毕竟很多大公司面试，都会问一些算法的问题，看基础扎不扎实","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xyywork2018.github.io/tags/JavaScript/"}],"keywords":[]},{"title":"Math算法","slug":"Math","date":"2018-09-16T16:00:00.000Z","updated":"2018-09-20T09:11:28.623Z","comments":true,"path":"2018/09/17/Math/","link":"","permalink":"https://xyywork2018.github.io/2018/09/17/Math/","excerpt":"","text":"以前开发项目的时候，用到Math的时候很少，但是感觉他的很多算法有很强大，所以现在结合着ES6系统的学习一下有关Math的一些主要用法，然后做学习记录，以备不时之需，哈哈，到时候巩固起来也很方便学习。 Math对象用于执行数学任务，在ES6中，新增了17个与数学相关的静态方法，但是只能在对象上调用 语法12var pi_value = Math.PI;var sqrt_value = Math.sqrt(15) Math函数不需要创建，直接引用就行，把Math作为对象使用就可以直接调用所有的属性和方法 Math的对象属性 常用Math对象方法和ES6新增方法1.Math.random(): 返回0~1之间的随机数2.Math.round(x): 返回四舍五入为最接近的整数3.Math.valueOf(): 返回Math对象的原始值4.Math.toSource(): 返回该对象的源码5.Math.ceil(x): 对数进行上舍入6.Math.floor(x): 对数进行下舍入7.Math.trunc(): 用于除去一个数的小数部分，返回一个整数部分,如果是非数值，则需要用Number方法将其先转为数值，对于非空和无法取整数的值，返回NaN12345678910111213Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc('123.456') // 123Math.trunc(true) // 1Math.trunc(false) // 0Math.trunc(null) // 0Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN 如果没有部署这个方法的环境，则可以用以下代码模拟123Math.trunc = Math.trunc || function(x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x)&#125; 8.Math.sign(): 判断一个数是正数，负数，还是零，对于非数值，会先转为数值，正数返回1，负数返回-1，0返回0，-0返回-0，其他值则返回NaN12345678Math.sign('') // 0Math.sign(true) // +1Math.sign(false) // 0Math.sign(null) // 0Math.sign('9') // +1Math.sign('foo') // NaNMath.sign() // NaNMath.sign(undefined) // NaN 如果没有部署方法的环境，则可以用以下代码模拟1234567Math.sign = Math.sign || function(x) &#123; x = + x; if (x === 0 || isNaN(X)) &#123; return x; &#125; return x &gt; 0 ? 1 : -1&#125; 9.Math.max(): 返回一个最大数（最高值）10.Math.min(): 返回一个最小值（最低值）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xyywork2018.github.io/tags/JavaScript/"}],"keywords":[]},{"title":"一些和字符串有关的算法","slug":"study","date":"2018-08-23T07:05:21.000Z","updated":"2018-09-20T10:39:33.460Z","comments":true,"path":"2018/08/23/study/","link":"","permalink":"https://xyywork2018.github.io/2018/08/23/study/","excerpt":"","text":"以前学习ES6的时候觉得好难，根本看不懂好么，也不明白为什么要学ES6，直到学习了vue之后，也开发过vue项目，和ES6相结合使用，发现真的是非常方便，而且ES6中的好多语法，感觉也比以前更加规范，提供了非常便捷的方法。所以，现在趁着项目的空档期，要重新认真的学习一次ES6，不断的提升自己的知识储备。技术更新太快，要努力跟上更新的脚步，不要落的太对多！ ES6是JavaScript语言的下一代标准，可以使用Babel转码器，将ES6代码转为ES5 前面的一些基础就不特意总结了，就总结一下经常使用到的方法,方便以后复习的时候查找 判断一个字符串中是否包含在另一个字符串中的几种方法includes()返回布尔值true或者false,也可以传入第二个参数,从第n个位置直到字符串结束；123const result = 'Hello World';result.includes('e'); // trueresult.includes('e', 9); // true 是从一个数组中匹配相同的字符串，但是数组中的每一个字符串都有相同的字符，这样返回的也会是false,通过索引匹配则会返回true123const result = ['123', '223', '323'];result.includes('2'); // falseresult[2].includes('2'); // true 在我开发项目的过程，遇到一种情况，就是在新添加章节名的时候要判断章节名称是否重复。实现方法：先判断章名称是否重复，再判断节名称是否重复。后台返回给我一个章名称的数组，通过循环章名称进行匹配，使用includes()方法会存在一个问题，只要前面的字符相同，就会返回true，提示章节名称已存在。后来通过find()方法解决该问题。 match()在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。12345const str = 'Hello world';const strN = '1 plus 2 equal 3'console.log(str.match('world')); // worldconsole.log(str.match('WORLD')); // nullconsole.log(strN.match(/\\d+/g)); // 1,2,3 (全局匹配的正则表达式来检索字符串中的所有数字) indexOf()和lastIndexOf()indexOf(): 指定某个字符串值在字符串中首次出现的位置,如要要是检索的字符串值没有出现，则返回-1（从左向右）lastIndexOpf: 指定字符串值在字符串中最后出现的位置，在一个字符串中的指定位置从后向前搜索（从右向左）123const str = 'Hello world';console.log(str.indexOf('World')); // -1console.log(str,indexOf('world')); // 6 find()和findIndex()find(): 用于找出第一个符合条件的数组成员，参数是一个回调函数，所有数组成员一次执行该回调函数，直到找出第一个返回值为true的成员，并返回该成员，如果没有符合条件的成员，则返回undefinedfindIndex(): 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-11[1,4,-5,10].find((item) =&gt; n &lt; 0) // -5 startsWith()和endsWith()startsWith(): 表示参数字符串是否在原字符串的头部，返回true或者falseendsWith(): 表示参数字符串是否在原字符串的尾部，返回true或者false123const str = 'Hello world';console.log(str.startsWith('world', 6)); // trueconsole.log(str.endsWith('Hello', 5)); // false 截取字符串的几种方法slice()可以从已有的数组中返回选定的元素，返回一个新的数组，包含从start到end（不包含该元素）的arrayObject中的元素（默认从0开始），不会修改原数组，会返回一个新数组 语法：arrayObject.slice(start, end) // start为必选，end为可选 12345let arr = new Array(3);arr[0] = 'xw';arr[1] = 'yw';arr[2] = 'wx';console.log(arr.slice(1)); // yw substring()用于提取字符串中介于两个指定下标之间的字符，会返回一个新的字符串，内容这是从start处到stop-1处的所有字符，长度为stop-start，该方法不接受负参数 语法：stringObject.substring(start, stop) // start为必选，stop为可选 123const str = 'Hello world';console.log(str.substring(3)); // lo worldconsole.log(str.substrin(3,7)); // lo w substr()可以在字符串中抽取start下标开始的指定数目的字符，返回一个新的字符串，包含从stringObject的start（包括start所指字符）处开始的length个字符，如果没有指定length，则返回的字符串包含从start到stringObject的结尾的字符，可以代替substring()和slice()使用 语法： stringObject.substr(statr, length) // start为必选，length为可选 123const str = 'Hello world';console.log(str.substr(3)); // lo worldconsole.log(str.substr(3,7)); // lo worl 注意： ECMAscript没有对该方法进行标准化，因此反对使用它 split()用于把一个字符串分割成字符串数组，返回一个字符串数组，该字符串数组是通过separator指定的边界处将字符串stringObject分割成子串创建的，返回的数组中的子串不包括separator自身 语法：stringObject.split(separator, howmany) // separator为必选，howmany为可选 12const str = 'Hello, how are you doing today';console.log(str.split(',')); // ['Hello','how are you doing today'] join()用于把数组中的所有元素放入一个字符串，和split()的用法相反，返回一个字符串 语法： arrayObject.join(separator) // separator为可选 12345let arr = new Array(3)arr[0] = \"George\"arr[1] = \"John\"arr[2] = \"Thomas\"console.log(arr.join('.')); // George.John.Thomas reverse()用于颠倒数组中元素的顺序，会改变原来的数组，不会创建新的数组 语法： arrayObject.reverse() 1let arr = ['George', 'John', 'Thomas'].reverse(); // ['Thomas', 'John', 'George'] 其他常用repeat()可以将原字符串重复n次，返回一个新的字符串，如果参数为负数，则会报错，参数如果是小数，则会被取整，参数是0到-1间的小数，则等同于0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0123'xw'.repeat(3); // xwxwxw'xw'.repeat(0); // '''xw'.repeat(2.9); // xwxw padStart和padEnd()padStart(): 用于头部补全padEnd(): 用于尾部补全 都可以接受两个参数，第一个参数是用来指定字符串的最小长度，第二个参数是用来补全的字符串，如果原字符串的长度，等于或大于指定的最小长度，咋返回原字符串，如果省略第二个参数，默认用空格补全长度 1234'x'.padStart(5, 'ab'); // 'ababx''x'.padEnd(4, 'ab'); // 'xaba''123456'.padStart(10, '0'); // \"0000123456\"'09-12'.padStart(10, 'YYYY-MM-DD'); // \"YYYY-09-12\" padStart的常见用途是为数值补全指定位数;提示字符串格式 模板字符串模板字符串是增强版的字符串，用反引号标识，可以用作普通字符串使用，也可以用来定义多行字符串，或者再字符串中嵌入变量,大括号内可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，模板字符串可以进行嵌套1234let name = 'Bob', time = 'today';`Hello $&#123;name&#125;,how are you $&#123;time&#125;?`let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;` replace()用于在字符串中用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子串，返回一个新的字符串，是用replacement替换了regexp的第一次匹配或所有匹配之后得到的 语法: stringObject.replace(regexp/substr, replacement) // regexp/substr为必选，replacement为必选 12345var str=\"Welcome to Microsoft!\"str=str + \"We are proud to announce that Microsoft has \"str=str + \"one of the largest Web Developers sites in the world.\"console.log(str.replace(/Microsoft/g, \"W3School\"));// Welcome to W3School! We are proud to announce that W3School has one of the largest Web Developers sites in the world. search()用于检索字符串找那个指定的子字符串，或者检索与正则表达式相匹配的子字符串，返回stringObject中第一歌与regexp相匹配的子串的起始位置,search对大小写敏感，如果检测不到，则返回-1 语法： stringObject.search(regexp) // regexp是需要在stringObject中检索的子串，可以是需要检索的RegExp对象 123const str = 'Visit W3School';console.log(str.search(/W3School/)); // 6console.log(str.search(/w3school/)); // -1 toString()可以把数组转换成字符串，并返回结果，返回值与没有参数的join()方法返回的字符串相同。当数组用于字符串环境时，JavaScript会调用这一方法将数组自动转换成字符串 语法：arrayObject.toString() 今天在codewars中做了一道题，是需要把数组中的每一个数组合成一个二进制数，再转换成十进制显示12345678var arr = [ 1, 1, 0, 0 ];const binaryArrayToNumber = arr =&gt; &#123; // 实现思路：1.首先需要把数组传成字符串（每一个字符和字符之间用逗号隔开）； // 2.再使用replace把逗号替换成\"\"; // 3.最后用parseInt转成整数; // 4.在传一个radix值，转成十进制即可。 return parseInt((arr.toString()).replace(/,/g, \"\"), 2); // 12&#125; 提交之后，看了其他大神的写法，发现还有更加方便的写法，同样能实现这个功能12var arr = [ 1, 1, 0, 0 ];const binaryArrayToNumber = arr =&gt; parseInt(arr.join(''), 2); // 12 另一种写法是使用reduce()实现，从左向右累加计算1234var arr = [ 1, 1, 0, 0 ];function binaryArrayToNumber(arr) &#123; return arr.reduce((a, b) =&gt; a &lt;&lt; 1 | b); // 12&#125; 这样一对比，还是自己会的少啊~~~~ shift()用于把数组的第一个元素从其中删除，并且返回第一个元素，但是该方法不创建新数组，二十直接修改原有的arrayObject,如果数组是空的，则返回undefined 语法: arrayObject.shiftP() 1let arr = ['George', 'John', 'Thomas'].shift(); // George pop()用户删除数组中最后一个字符，并返回该字符,数组的长度-1，如果数组为空，则返回undefined 语法：arrayObject.pop() 1let arr = ['George', 'John', 'Thomas'].pop(); // Thomas","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xyywork2018.github.io/tags/JavaScript/"}],"keywords":[]},{"title":"错题记录(三)","slug":"wrong-record-2","date":"2018-08-21T01:40:49.000Z","updated":"2018-08-21T07:27:33.246Z","comments":true,"path":"2018/08/21/wrong-record-2/","link":"","permalink":"https://xyywork2018.github.io/2018/08/21/wrong-record-2/","excerpt":"","text":"错题知识点记录1.树形结构中元素之间存在一对多的关系；线性结构元素之间存在一对一的关系；图形结构元素之间存在多对多的关系2.栈和队列都是一种线性数据结构 常用的线性结构：线性表、栈、列队、双列队、数组、字符串常用的非线性结构：二维数组、多维数组、树（二叉树等）、图、广义表 3.栈中元素的进出原则是先进栈后出栈4.从无向图的任一顶点出发进行一次图遍历即可访问所有顶点，是连通图5.某完全二叉树共有200个结点，则该二叉树中有100个叶子结点 如果一共有的结点个数为N(偶数)，叶子节点为N/2如果一共有的结点个数为N(基数)，叶子节点为N/2+1 6.最大容量为n的循环队列，队尾指针是rear，队头是front，循环队列为空：front=rear；循环列队为满：(rear+1)%n==front7.在二叉树结点的前序序列、中序序列和后序序列中,所有叶结点的先后顺序完全相同8.(100,80,90,60,120,110,130)构造二叉树排序树，第一个(100)数为根数，依次往下排列，比根大的放右边，比根小的放左边9.以行序为主序存储二维数组A=array[100][100],设每个数据元素占2个存储单位，基地址A[0][0]为10，则A[5, 5]的地址是1020 5*100*2+5*2+10=1020注意：基地址为10 10.深度为k的完全二叉树中最少有2^(k-1)个结点11.采用二叉链表作为存储结构,树的前序遍历和其相应的二叉树的前序遍历的结果是一样的12.取第i个结点及其前驱，则采用顺序表存储方式最节省时间13.串(字符串)是一种特殊的线性表，其特殊性体现在数组元素是一个字符14.单链表的存储密度小于1 存储密度=单链表数据项所占空间/结点所占空间结点所占空间有数据域和指针域组成 15.大小为MAX的循环队列中，f为当前对头元素位置，r为当前队尾元素位置(最后一个元素的位置)，则任意时刻，队列中的元素个数为(r-f+MAX)%MAX 求队列公式为： （rear-front+Max）%Max ———该公式中的 rear指向队尾元素的下一个位置，而本题中 r 指 向队尾元素位置循环列队需要取余 16.若需给子scope发送消息，需使用$broadcast()方法 向上冒泡：$emit()向下传播：$broadcast() 17.n个结点的二叉树的形态：C(n)=(1/(n+1))*((2*n)!/(n!*n!)) 具有3个结点的二叉树有C(3) = (2*3)!/(3！*3！)/(3+1)=5种形态","categories":[],"tags":[{"name":"wrong question","slug":"wrong-question","permalink":"https://xyywork2018.github.io/tags/wrong-question/"}],"keywords":[]},{"title":"错题记录(二)","slug":"wrong-record-1","date":"2018-08-20T01:40:49.000Z","updated":"2018-08-21T01:48:06.284Z","comments":true,"path":"2018/08/20/wrong-record-1/","link":"","permalink":"https://xyywork2018.github.io/2018/08/20/wrong-record-1/","excerpt":"","text":"错题知识点记录1.使用break跳出Array的forEach循环2.C#程序段结果：int[][] array = new int[3][]{new int[3]{5,6,2},new int[5]{6,9,7,8,3}, new int[2]{3,2}},返回会溢出3.若用一个大小为6的数组来实现循环队列，且当rear和front的值分别为0和3。当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为2和4 a.列队添加元素是在队尾，删除元素在对头b.添加元素，尾指针rear+1；删除元素，头指针front+1 4.存取任一指定序号的元素和在最后进行插入和删除运算，利用顺序表(数组)最省时间5.一个5*4的矩阵，有150个长方形？（正方形也算是长方形） 长任取两个点C(6,2)宽任取两个点C(5,2) = 15 10 = 150两个点决定一条线，长为5则一共有6个点，宽为4则一共有5个点 6.下面代码中可以正确操作数组元素是：*(*(a+i)+j)=1和*(a[i]+j)=112345678int main() &#123; int a[n][m] = &#123;&#123;0,0&#125;,&#123;0,0&#125;&#125;; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; //访问二维数组a的值、选项代码 &#125; &#125;&#125; *(a+i)与a[i]是等效的；*(a[i]+j)与a[i][j]等效 7.下面这段代码中的时间复杂度为(m*n)123for (int i=0;i&lt;m;i++)for (int j=0;j&lt;n;j++)a[i][j]=i*j 第一个for循环执行m次，第二个for循环执行n次，嵌套后，每执行一次第一个for循化，就会执行n次第二个，因此共执行m*n次 8.为实现快速排序算法，待排序序列宜采用的存储方式为顺序存储9.哈夫曼编码是哈夫曼树的一个应用。哈夫曼树：又被称为最优二叉树，是一种带权路径长度最短的二叉树。带权路径长度：就是树中所有的叶结点的权值乘上其到根结点的路径长度。路径长度：若根节点为0层，叶结点到根结点的路径长度为叶结点的层数。 树的带权路径长度： WPL = (W1L1+W2L2+W3L3+…+WnLn) 哈夫曼编码步骤：1.对给定的n个权值，从小到大进行排序；2.在给定的权值中选取两个最小的最为新构造的二叉树的左右子树(左小右大)，新二叉树的根结点的权值为其左右子树的根结点的权值之和；3.从给定的去权值中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合中；4.重复第二和第三步，直到有且只有一颗二叉树为止。 10.二叉排序树删除一个结点，仍是二叉排序树 二叉排序树的左子树结点值均小于根结点值；右子结点值均大于根结点值 11.有n个顶点、e条边且使用邻接表存储有向图进行广度优先遍历，算法的时间复制度是(n+e) 若采用邻接矩阵存储，时间复杂度为O(n^2);若采用邻接链表存储，时间复杂度为O(n+e); 12.在排序算法中每一项都与其他各项进行比较,计算出小于该项的项的个数,以确定该项的位置叫枚举排序13.四个平面最多把三维空间分成15个部分 有4个平面，4个平面相连有4个顶点，有6条棱，然后形成1个三棱锥，所以是4+4+6+1=15 14.线性表采用链表存储时,结点和结点内部的存储空间一般是连续的15.交换机主要工作在数据链路层16.input:hover+.tooltip可以在鼠标滑过的时候出现tip提示具体样式参考代码：容易与简单的css三角形1234&lt;div&gt; &lt;input placeholder=\"请输入文字\"/&gt; &lt;div class=\"tooltip\"&gt;只能够输入英文字母、数字和下划线与中划线&lt;/div&gt;&lt;/div&gt; 17.回调地狱(callback hell):JS异步编程，或使用大量回调函数是，使其代码变的难以阅读和维护 解决回调地狱的方法：1.让代码更扁薄一些2.模块化3.处理每一个单独的报错4.通过Promise原型的then()方法可以分别指定某个异步操作的回调 18.闭包：有权限访问两一个函数作用域中的变量函数。作用在于：可以通过闭包，设计私有变量及方法。缺点：常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 特点：1.函数嵌套函数2.内部函数可以访问外部函数的变量3.参数和变量不会被回收1234567891011function test() &#123; var a = 1; // 变量a在test方法外是无法访问的 // 嵌套一个匿名函数，通过return返回 return function() &#123; // test作用域中的变量a可以在匿名函数中访问 console.log(a); &#125;&#125;// 当执行test方法后，变量a所占内存并不会释放，已达到嵌套函数还可以访问的目的var try = test();try(); // 打印出a的值 如何避免this丢失：1.可是用ES6中的箭头函数2.将this在函数定义外层作用域保存下来传递到闭包函数中 19.101枚硬币中有一枚假币，有一个无砝码的天平，在最坏情况下最少称2次，可以判断假币比真币重还是轻 先把硬币分成两部分A和B，每部分各50个第一种：进行第一次称重，如果A=B，则剩下的1个为假，再随便取一个硬币，进行第二次称重，就能比较出假币比真币重还是轻第二种：进行第一次称重，如果A!=B，则A或B中含有假币，再将A分成A1和A2，分别是25个，进行第二次比较，如果A1=A2，则A为真币，A&gt;B，真币重；A&lt;B，假币重；如果A1!=A2，则中含有假币，A&lt;B，真币重；A&gt;B，假币重","categories":[],"tags":[{"name":"wrong question","slug":"wrong-question","permalink":"https://xyywork2018.github.io/tags/wrong-question/"}],"keywords":[]},{"title":"错题记录(一)","slug":"wrong-record","date":"2018-08-18T02:36:21.000Z","updated":"2018-08-20T01:22:50.048Z","comments":true,"path":"2018/08/18/wrong-record/","link":"","permalink":"https://xyywork2018.github.io/2018/08/18/wrong-record/","excerpt":"","text":"错题知识点记录最近在牛客网每天都会刷一些面试题、笔试题，找到自己的不足，现在就通过博客把自己的错题都记录下来，空闲时间可以经常看，巩固知识点，提高学习效率 JavaScript1.在一个表单中，如果想要给输入框添加一个输入验证，可以使用JavaScript中onmouseover()和onmouseout()事件【在jQuery中取而代之的是hover(over, out)】和change(fn)事件实现，是JavaScript中onmouseover()和 hover(over, out): 一个模仿悬停事件(鼠标移动到一个对象上面及移出这个对象)的方法，移入时会触发一个函数，移出是会触发第二个函数 change(fn): 在每一个匹配元素的change事件中绑定一个处理函数，会在元素是去焦点的时候触发，也会当值在获得焦点后改变时触发；fn: 在每一个匹配元素的change事件中绑定的处理函数 2.History: 对象包含用户(在浏览器窗口中)访问过的URL,是window对象的一部分，可通过window.history属性对其进行访问的，提供了与历史清单有关的信息&emsp;Location: 对象包含有关当前打开的URL的信息(一起工作的方法和属性)，是一个静态的对象&emsp;Window: 对象处于对象层次的最顶层，提供了处理Navigator窗口的方法和属性&emsp;Navigator: 对象提供有关浏览器的信息&emsp;Document： 对象包含与文档元素一起工作的对象，将这些元素封装起来供编程人员使用 3.export var firstName=’Michael’ 符合ES6的写法，详情参照export用法和import用法 4.angular.js的服务实质上是单例服务，有三个要点：某个类只能有一个实例，必须自行创建这个实例，必须自行向整个系统系统这个实例 5.代码中f只能获取到a,但是获取不到b12345var F = function()&#123;&#125;;Object.prototype.a = function()&#123;&#125;;Function.prototype.b = function()&#123;&#125;;var f = new F();console.log(f.a, f.b,F.a, F.b); 所有普通对象都源于这个Object.prototype对象，只要是对象都可以访问到a,f通过new关键词进行函数调用，之后无论如何都会返回一个与F关联的普通对象（因为不是通过函数构造创建的对象，所以不是函数对象，也就 取不到b了） 6.下面代码中，var a=b=5因为代码赋值是从右向左，所以应该是b=5;var a=b;但是其中var a=b是当前作用域的全局变量，b=5并没有定义为当前作用域的全局变量，会申明提前在全局作用域中（提前的只是声明，赋值操作不会被提前）12345(function() &#123; var a = b = 5;&#125;)();console.log(b); // 5console.log(a); // a is not defined 7.if(obj){}等价于if(obj !== null){},boolea是基础数据类型，Boolea(0)返回布尔值false，new Boolea (0)返回对象12345678var x = new Boolean(false);if (x) &#123; console.log('hi'); // hi&#125;var y = Boolean(0);if (y) &#123; console.log('hello');&#125; 8.短路或：如果第一项返回true，结果为true，如果第一项返回false，结果为第二项12var a = 4399 &lt; 0 || typeof(4399 + '');console.log(a); // String 9.this当在函数调用时指向window；方法调用时指向调用对象；当apply和call上下文调用的时候指向传入的第一个参数；构造函数调用指向实例对象10.hasOwnProperty: 用来检测一个对象是否含有特定的自身属性，该方法会返回一个布尔值&emsp; isPrototypeOf： 用于测试一个对象是否存在于另一个对象的原型链上11.下面代码中，one只是定义但是没有赋值，所以one就是undefined，undefined和null转换问Boolean类型后都是false，===不会转换，所以undefined和null不相等123var one;var two = null;console.log(one == two, one === two); // false true == 和 === 的区别：&emsp;a.对于string，number等基础类型，是有区别的，不同类型之间的比较，==之比较’转化成同一类型后的值’看’值’是否相等，===如果类型不同，其结果不同；同类型比较，直接进行’值’比较，两者结果一样&emsp;b.对于Array,Object等高级类型，==和===是没有区别的,进行“指针地址”比较&emsp;c.基础类型与高级类型，==和===是有区别的,对于==，将高级转化为基础类型，进行’值’比较;因为类型不同，===结果为false12.函数声明可以被提前，但函数表达式不能被提前1234567(function()&#123; var x = foo(); var foo = function foo() &#123; return 'foobar' &#125; return x&#125;) // 类型错误 其他1.一个口袋装着若干个篮球和若干个红球，随机抽取两个球，第一个是篮球的概率为0.5；第一个为篮球第二个为红球的概率为0.2。如果已知第一个是篮球，第二个红球的概率是0.4 P(A|B) = P(A and B)/P(B) = 0.2 / 0.5 = 0.4 2.一个数据表express(No.SenderName, REeceiverName.SenderAddress, ReceiverAdderss,Charge, Weight, Type)可以查询出几个简单的相关信息：所有寄件人第一个字为’李’的快递单(Select * From express Where name like “李%”);所有重量在10kg以下的快递，并输出单号和收费(Select No, Charge From express Where Weight &lt;10);统计表中不同类型的快递单的平均重量，并按照从大到小排列(Select Type, avg(Weight) From express Group by Type Order by avg(Weight));3.网络层是路由器，数据链路层是交换机，物理层是光纤，传输层是TCP/UDP协议4.线性表采用链表存储时,结点和结点内部的存储空间可以是不连续的5.四个平面最多把三维空间分成15个部分6.一天，harlan的店里来了一位顾客，挑了25元的货，顾客拿出100元，harlan没零钱找不开，就到隔壁飞白的店里把这100元换成零钱，回来给顾客找了75元零钱。过一会，飞白来找harlan，说刚才的是假钱，harlan马上给飞白换了张真钱，问harlan赔了75元+25元货的成本价 顾客： 100假钱 = 25元货 + 75元真钱，赚到了25元货和75元真钱飞白： 100真钱 = 100元假钱，发现假钱后，100元假钱 = 100元真钱，无损失 7.二叉排序树删除一个结点后，仍是二叉排序树8.具有7个顶点的有向图至少应有7条边才可能成为一个强连通图 有n个顶点的强连通图最多有n(n-1)条边，最少有n条边","categories":[],"tags":[{"name":"wrong question","slug":"wrong-question","permalink":"https://xyywork2018.github.io/tags/wrong-question/"}],"keywords":[]}]}